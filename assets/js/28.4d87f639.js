(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{605:function(s,a,e){"use strict";e.r(a);var n=e(10),t=Object(n.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"一、什么是pnpm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是pnpm"}},[s._v("#")]),s._v(" 一、什么是pnpm")]),s._v(" "),e("p",[s._v("pnpm 本质上就是一个包管理器，这一点跟 npm/"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=yarn&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("yarn"),e("OutboundLink")],1),s._v(" 没有区别，但它作为杀手锏的两个优势在于:")]),s._v(" "),e("ul",[e("li",[s._v("包安装速度极快；")]),s._v(" "),e("li",[s._v("磁盘空间利用非常高效。")])]),s._v(" "),e("p",[s._v("它的安装也非常简单。")]),s._v(" "),e("div",{staticClass:"language-powershell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-powershell"}},[e("code",[s._v("npm i "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("g pnpm\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h1",{attrs:{id:"二、特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、特性"}},[s._v("#")]),s._v(" 二、特性")]),s._v(" "),e("h2",{attrs:{id:"_1-速度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-速度"}},[s._v("#")]),s._v(" 1.速度")]),s._v(" "),e("p",[s._v("在绝多大数场景下，包安装的速度都是明显优于 npm/yarn，速度会比 npm/yarn 快 2-3 倍。")]),s._v(" "),e("h2",{attrs:{id:"_2-高效利用磁盘空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-高效利用磁盘空间"}},[s._v("#")]),s._v(" 2.高效利用磁盘空间")]),s._v(" "),e("p",[s._v("pnpm 内部使用"),e("code",[s._v("基于内容寻址")]),s._v("的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:")]),s._v(" "),e("ul",[e("li",[e("font",{attrs:{color:"orange"}},[s._v("不会重复安装同一个包")]),s._v("。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，"),e("font",{attrs:{color:"orange"}},[s._v("后面再次使用都会直接使用 "),e("code",[s._v("hardlink")]),s._v("(硬链接）")])],1),s._v(" "),e("li",[e("font",{attrs:{color:"orange"}},[s._v("即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码")]),s._v("。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 "),e("code",[s._v("hardlink")]),s._v("，仅仅写入那"),e("code",[s._v("一个新增的文件")]),s._v("。")],1)]),s._v(" "),e("h2",{attrs:{id:"_3-支持monorepo-单一代码库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-支持monorepo-单一代码库"}},[s._v("#")]),s._v(" 3.支持monorepo （单一代码库）")]),s._v(" "),e("p",[s._v("随着前端工程的日益复杂，越来越多的项目开始使用 monorepo。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的"),e("code",[s._v("packages")]),s._v("目录下，那么一个子项目就代表一个"),e("code",[s._v("package")]),s._v("。")]),s._v(" "),e("p",[e("strong",[s._v("好处")])]),s._v(" "),e("p",[s._v("每个团队的所有源代码（和其他文件/数字资产）保存在一个存储库中。这样更容易与大家分享。")]),s._v(" "),e("h2",{attrs:{id:"_4-安全性高"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-安全性高"}},[s._v("#")]),s._v(" 4.安全性高")]),s._v(" "),e("p",[s._v("​\t\t在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。pnpm通过独特的依赖管理方式解决了非法访问的风险。")]),s._v(" "),e("h1",{attrs:{id:"依赖管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖管理"}},[s._v("#")]),s._v(" 依赖管理")]),s._v(" "),e("h2",{attrs:{id:"npm和yarn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npm和yarn"}},[s._v("#")]),s._v(" npm和yarn")]),s._v(" "),e("p",[s._v("执行 npm/yarn install之后，"),e("code",[s._v("包如何到达项目 node_modules 当中")]),s._v("。其次，node_modules "),e("code",[s._v("内部如何管理依赖")]),s._v("。")]),s._v(" "),e("p",[s._v("执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:")]),s._v(" "),e("p",[s._v("- 1. 将依赖包的版本区间解析为某个具体的版本号\n- 2. 下载对应版本依赖的 tar 包到本地离线镜像\n- 3. 将依赖从离线镜像解压到本地缓存\n- 4. 将依赖从缓存拷贝到当前目录的 node_modules 目录")]),s._v(" "),e("p",[s._v("然后，对应的包就会到达项目的"),e("code",[s._v("node_modules")]),s._v("当中。")]),s._v(" "),e("p",[s._v("在npm1和npm2，项目依赖树呈现的是嵌套结构，会导致层级太深和大量重复依赖")]),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[s._v("node_modules\n└─ foo\n   ├─ index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n   ├─ "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("json\n   └─ node_modules\n      └─ bar\n         ├─ index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n         └─ "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("json\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[e("font",{attrs:{color:"orange"}},[s._v("从 npm3 开始，包括 yarn，都着手来通过"),e("code",[s._v("扁平化依赖")]),s._v("的方式来解决这个问题")])],1),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[s._v("node_modules\n├─ foo\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("  ├─ index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("  └─ "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("json\n└─ bar\n   ├─ index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n   └─ "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("json\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("p",[s._v("所有的依赖都被拍平到"),e("code",[s._v("node_modules")]),s._v("目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的"),e("code",[s._v("node_modules")]),s._v("当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。")]),s._v(" "),e("p",[e("strong",[s._v("问题")])]),s._v(" "),e("ol",[e("li",[s._v("依赖结构的"),e("strong",[s._v("不确定性")]),s._v("。")]),s._v(" "),e("li",[s._v("扁平化算法本身的"),e("strong",[s._v("复杂性")]),s._v("很高，耗时较长。")]),s._v(" "),e("li",[s._v("项目中仍然可以"),e("strong",[s._v("非法访问")]),s._v("没有声明过依赖的包")])]),s._v(" "),e("p",[s._v("假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的:")]),s._v(" "),e("img",{staticStyle:{zoom:"30%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203231556715.png",alt:"img"}}),s._v(" "),e("p",[s._v("扁平处理后，依赖结构能以下的情况都有可能出现，具体要取决于 foo 和 bar 在 "),e("code",[s._v("package.json")]),s._v("中的位置。")]),s._v(" "),e("p",[s._v("这就是为什么会产生依赖结构的"),e("code",[s._v("不确定")]),s._v("问题，也是 "),e("code",[s._v("lock 文件")]),s._v("诞生的原因，无论是"),e("code",[s._v("package-lock.json")]),s._v("(npm 5.x才出现)还是"),e("code",[s._v("yarn.lock")]),s._v("，都是为了保证 install 之后都产生确定的"),e("code",[s._v("node_modules")]),s._v("结构。")]),s._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203231556124.png"}}),s._v(" "),e("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203231556551.png",alt:"img"}}),s._v(" "),e("h2",{attrs:{id:"测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[s._v("#")]),s._v(" 测试")]),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[s._v("pnpm init "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("y\npnpm install express\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("结果如下")]),s._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203231629931.png",alt:"image-20220323162948873"}}),s._v(" "),e("p",[s._v("可以直接就看到了"),e("code",[s._v("express")]),s._v("，但值得注意的是，这里仅仅只是一个"),e("font",{attrs:{color:"orange"}},[e("code",[s._v("软链接")])]),s._v("，里面并没有 node_modules 目录，如果是真正的文件位置，那么根据 node 的包加载机制，它是找不到依赖的。")],1),s._v(" "),e("p",[s._v("express的真正位置在"),e("code",[s._v(".pnpm/express@4.17.1/node_modules/express")])]),s._v(" "),e("p",[e("code",[s._v(".pnpm")]),s._v("目录下虽然呈现的是扁平的目录结构，顺着"),e("code",[s._v("软链接")]),s._v("慢慢展开，其实就是嵌套的结构！")]),s._v(" "),e("p",[s._v("在根目录的node_modules不再是我们项目所引用不同包的内部依赖混在一起，而是跟 package.json 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 node_modules 当中，但整体上，根目录的"),e("code",[s._v("node_modules")]),s._v("比以前还是清晰和规范了许多。（比如项目引入了a包，而a包内部使用了b包，b包的声名不会出现在根目录的node_modules内，而是在.pnpm内）")]),s._v(" "),e("h1",{attrs:{id:"安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全"}},[s._v("#")]),s._v(" 安全")]),s._v(" "),e("p",[s._v("pnpm 这种依赖管理的方式也很巧妙地规避了"),e("code",[s._v("非法访问依赖")]),s._v("的问题，也就是只要一个包未在 package.json 中声明依赖，那么在项目中是无法访问的。")]),s._v(" "),e("p",[s._v("但在 npm/yarn 当中是做不到的。如果 A 依赖 B， B 依赖 C，那么 A 就算没有声明 C 的依赖，由于有依赖提升的存在，C 被装到了 A 的"),e("code",[s._v("node_modules")]),s._v("里面，那我在 A 里面用 C，跑起来没有问题呀，我上线了之后，也能正常运行啊。不是挺安全的吗？")]),s._v(" "),e("p",[s._v("第一，你要知道 B 的版本是可能随时变化的，假如之前依赖的是"),e("code",[s._v("C@1.0.1")]),s._v("，现在发了新版，新版本的 B 依赖 "),e("code",[s._v("C@2.0.1")]),s._v("，那么在项目 A 当中 npm/yarn install 之后，装上的是 2.0.1 版本的 C，而 A 当中用的还是 C 当中旧版的 API，可能就直接报错了。")]),s._v(" "),e("p",[s._v("第二，如果 B 更新之后，可能不需要 C 了，那么安装依赖的时候，C 都不会装到"),e("code",[s._v("node_modules")]),s._v("里面，A 当中引用 C 的代码直接报错。")]),s._v(" "),e("p",[s._v("还有一种情况，在 monorepo 项目中，如果 A 依赖 X，B 依赖 X，还有一个 C，它不依赖 X，但它代码里面用到了 X。由于依赖提升的存在，npm/yarn 会把 X 放到根目录的 node_modules 中，这样 C 在本地是能够跑起来的，因为根据 node 的包加载机制，它能够加载到 monorepo 项目根目录下的 node_modules 中的 X。但试想一下，一旦 C 单独发包出去，用户单独安装 C，那么就找不到 X 了，执行到引用 X 的代码时就直接报错了。")]),s._v(" "),e("h1",{attrs:{id:"具体使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体使用"}},[s._v("#")]),s._v(" 具体使用")]),s._v(" "),e("h2",{attrs:{id:"安装包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装包"}},[s._v("#")]),s._v(" 安装包")]),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 安装 axios")]),s._v("\npnpm install axios\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 安装 axios 并将 axios 添加至 devDependencies")]),s._v("\npnpm install axios "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("D\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 安装 axios 并将 axios 添加至 dependencies")]),s._v("\npnpm install axios "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h2",{attrs:{id:"移除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移除"}},[s._v("#")]),s._v(" 移除")]),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 移除 axios")]),s._v("\npnpm uninstall axios "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v("filter "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("a\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("h3",{attrs:{id:"pnpm-link"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-link"}},[s._v("#")]),s._v(" pnpm link")]),s._v(" "),e("p",[s._v("将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链接。如:")]),s._v(" "),e("div",{staticClass:"language-go line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[s._v("pnpm link "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("axios\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("blockquote",[e("p",[s._v("参考：https://blog.csdn.net/qiwoo_weekly/article/details/114109197")])])])}),[],!1,null,null,null);a.default=t.exports}}]);