(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{644:function(t,v,_){"use strict";_.r(v);var a=_(10),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"基础篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[t._v("#")]),t._v(" 基础篇")]),t._v(" "),_("h2",{attrs:{id:"_1-1-tcp-ip-网络模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-tcp-ip-网络模型"}},[t._v("#")]),t._v(" 1.1 TCP/IP 网络模型")]),t._v(" "),_("p",[t._v("不同设备的通信，需要进行网络通信，设备是多样性的，因此通信需要通用的网络协议进行规范。")]),t._v(" "),_("p",[t._v("网络协议分为应用层、传输层、网络层、网际层、物理层")]),t._v(" "),_("p",[_("strong",[t._v("应用层")])]),t._v(" "),_("p",[t._v("用户直接通过应用层的软件通信，应用层会将数据传给下一层也就是传输层")]),t._v(" "),_("p",[_("strong",[t._v("传输层")])]),t._v(" "),_("p",[t._v("传输层负责为应用层提供网络支持。传输层有两个协议TCP和UDP协议。大部分应用使用的是TCP协议，TCP具备流量控制、超时重传、拥塞控制等功能，都是为了保证数据包能可靠的传输给对方。UDP协议提供不可靠的包传输，但实时性更好、效率更高。")]),t._v(" "),_("p",[t._v("应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当传输层的数据包⼤⼩超过 MSS（TCP 最⼤ 报⽂段⻓度） ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新新这⼀个分块，⽽不⽤重新新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP 段（TCP Segment）。")]),t._v(" "),_("p",[t._v("当设备作为接收方时，需要一个编号区分应用也就是端口号。"),_("font",{attrs:{color:"orange"}},[t._v("HTTP协议默认端口号80，22端口号用于远程登录服务器。")]),t._v("对于浏览器（客户端）中的每个标 签栏都是⼀个独⽴的进程，操作系统会为这些进程分配临时的端口号。")],1),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("传输层会在报文加上端口号区分数据是给哪个应用的")])],1),t._v(" "),_("p",[_("strong",[t._v("网络层")])]),t._v(" "),_("p",[t._v("⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装 成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹ 络的 IP 报⽂。")]),t._v(" "),_("p",[t._v("网络层负责将数据从一个设备传输到另一个设备，需要通过IP地址对设备进行区分。对应IPv4协议，IP地址又分为网络号和主机号，即区分属于哪个子网和子网的哪个主机。通过子网掩码得出 。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211455943.png",alt:"image-20220221145454792"}})]),t._v(" "),_("p",[_("strong",[t._v("数据链路层")])]),t._v(" "),_("p",[t._v("当数据包到达对应网络后，需要一个MAC地址来告诉路由器要将数据送到哪个设备，这就是数据链路层的作用。路由器通过ARP协议找到目的的MAC地址。")]),t._v(" "),_("p",[_("strong",[t._v("物理层")])]),t._v(" "),_("p",[t._v("负责将数据转换成电信号，为数据链路层提供二进制传输服务。")]),t._v(" "),_("h1",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),_("h2",{attrs:{id:"_2-1-http常见面试题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-http常见面试题"}},[t._v("#")]),t._v(" 2.1 HTTP常见面试题")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211459929.png",alt:"image-20220221145908865"}}),t._v(" "),_("h3",{attrs:{id:"http是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http是什么"}},[t._v("#")]),t._v(" HTTP是什么")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("HTTP是超文本传输协议，是一个运用在计算机世界的协议，他用计算机能理解的语言规定了计算机之间交流通信的规范，还包括通信的各种控制和处理方式。")]),t._v("HTTP是双向协议，但允许传输时进行中转。超文本是指各种信息展示方式的混合体（如视频、图片），能够实现超链接，即从一个超文本跳转到另一个超文本。常见的HTML就是一种超文本的展示形式。HTML本身只是传文本，但是能够通过浏览器解释编程一个丰富的网页。")],1),t._v(" "),_("h3",{attrs:{id:"状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("状态码")]),t._v(" "),_("th",[t._v("含义")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1XX")]),t._v(" "),_("td",[t._v("提示信息，表示还有后续操作")])]),t._v(" "),_("tr",[_("td",[t._v("2XX")]),t._v(" "),_("td",[t._v("成功响应，报文被正确处理")])]),t._v(" "),_("tr",[_("td",[t._v("3XX")]),t._v(" "),_("td",[t._v("资源发生变动，需要发起新请求")])]),t._v(" "),_("tr",[_("td",[t._v("4XX")]),t._v(" "),_("td",[t._v("客户端错误，报文错误，服务器无法处理")])]),t._v(" "),_("tr",[_("td",[t._v("5XX")]),t._v(" "),_("td",[t._v("服务器错误，内部操作时出错")])])])]),t._v(" "),_("h3",{attrs:{id:"常见字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见字段"}},[t._v("#")]),t._v(" 常见字段")]),t._v(" "),_("p",[_("strong",[t._v("HOST")])]),t._v(" "),_("p",[t._v("指定服务器的域名")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211509247.png",alt:"image-20220221150929194"}}),t._v(" "),_("ul",[_("li",[_("code",[t._v("Content-Length")]),t._v("字段：本次响应的数据长度")]),t._v(" "),_("li",[t._v("Connection 字段：表示使用长连接或端连接"),_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211511886.png",alt:"image-20220221151101843"}})]),t._v(" "),_("li",[t._v("Content-Type：告诉客户端本次的数据个数")]),t._v(" "),_("li",[t._v("Content-Encoding 字段：本次使用的数据压缩个数")]),t._v(" "),_("li",[t._v("Accept-Encoding字段：可接受的数据压缩格式")]),t._v(" "),_("li",[t._v("Accept：可接受的数据个数")])]),t._v(" "),_("h3",{attrs:{id:"get和post"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post"}},[t._v("#")]),t._v(" get和post")]),t._v(" "),_("ul",[_("li",[_("font",{attrs:{color:"orange"}},[t._v("get是安全和幂等的请求方法，不会破坏服务器的资源且执行操作的结果相同")]),t._v("；post是不安全的，会改变服务器资源状态。")],1),t._v(" "),_("li",[t._v("get的参数只能是ASCII个数，post参数没有限制")]),t._v(" "),_("li",[t._v("get请求时会将header和body的数据包一起发送，post会先发送header包，待服务器表示200 continue状态码时再发送body包。火狐浏览器post也只发送一个包")]),t._v(" "),_("li",[t._v("get实际也能做到post一样的请求，但为了符合规范，还是不能随便混用")])]),t._v(" "),_("h3",{attrs:{id:"http特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http特性"}},[t._v("#")]),t._v(" HTTP特性")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("简单")]),t._v(" "),_("p",[t._v("HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习 和使⽤的⻔槛。")])]),t._v(" "),_("li",[_("p",[t._v("灵活易扩展")]),t._v(" "),_("p",[t._v("HTTP协议的请求方法组成要求并没有规定死，开发人员可以自定义和扩充。且HTTP在第七层，可以修改下层实现更多功能，如HTTPS在传输层和应用层添加了TSL层实现安全传输。")])]),t._v(" "),_("li",[_("p",[t._v("应用广泛和跨平台")]),t._v(" "),_("p",[t._v("可运用于手机、电脑等...")])])]),t._v(" "),_("h3",{attrs:{id:"http的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的缺点"}},[t._v("#")]),t._v(" HTTP的缺点")]),t._v(" "),_("p",[_("code",[t._v("http")]),t._v("的一些特性即是其优点也是其缺点，"),_("font",{attrs:{color:"orange"}},[t._v("由于"),_("code",[t._v("http")]),t._v("是无状态的，虽然避免了额外空间存储状态信息，但是需要其他操作（cookie认证）处理有关联性的请求（如身份认证）；HTTP的是明文传输的，方便开发人员调试，但也导致了安全问题，信息容易暴露。")])],1),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("由于http明文传输的不安全性，需要在应用层和传输层之间添加一层TSL层来保证信息的安全传输")])],1),t._v(" "),_("h3",{attrs:{id:"http的性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的性能"}},[t._v("#")]),t._v(" "),_("font",{attrs:{color:"orange"}},[t._v("HTTP的性能")])],1),t._v(" "),_("p",[_("strong",[t._v("长连接")])]),t._v(" "),_("p",[t._v("HTTP的通信模式是应答通信，在客户端对服务端进行通信时，需要通过TCP协议建立起连接。也就是三次握手。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("早期HTTP1.0在客户端每次发起请求后，在服务器响应完成后就会断开连接，因此新请求需要重新建立连接，这虽然减轻服务器的负载，但也导致了很多额外开销；")])],1),t._v(" "),_("p",[t._v("HTTP1.1提出了长连接的通信方式，在通信双方建起连接后，只要没有提出断开请求，就会一致保存TCP连接状态。")]),t._v(" "),_("p",[_("strong",[t._v("管道网络通信")])]),t._v(" "),_("p",[t._v("HTTP1.1的长连接能够支持管道传输，不必像HTTP1.1般必须等待前一个请求的响应完成时才能发起新的请求，而是支持连续发送新请求，这能够减少整体响应时间。")]),t._v(" "),_("p",[_("strong",[t._v("线头阻塞")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("尽管HTTP1.1支持能新请求的连接发送，服务端如果响应资源时出现阻塞现象，也会影响后续请求。这就是线头阻塞，HTTP1.0的问题在HTTP1.1没有得到根本性解决。浏览器为了避免线头阻塞，允许打开多个TCP连接，让不同TCP连接进行并行传输。")])],1),t._v(" "),_("h3",{attrs:{id:"http和https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[t._v("#")]),t._v(" HTTP和HTTPS")]),t._v(" "),_("p",[_("strong",[t._v("HTTP 与 HTTPS 有哪些区别？")])]),t._v(" "),_("ol",[_("li",[t._v("HTTP是超文本传输协议，明文传输，存在安全我呢提，HTTPS为了保证信息安全，在应用层和传输层之间增加了TSL层，对报文进行加密。")]),t._v(" "),_("li",[t._v("HTTP在TCP三次握手后就可以实现通信，HTTPS在TCP三次握手后，还需要进行TSL/SSL握手才能实现报文加密")]),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("HTTP默认80端口、HTTPS默认443端口")])],1),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("HTTPS协议需要向CA（可靠的证书权威机构）申请数字证书验证服务器身份")])],1)]),t._v(" "),_("h3",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("HTTPS是在HTTP和TCP之间加了SSL/TSL协议，解决了HTTP明文传输导致的安全问题。具体是通过信息加密、数据校验、身份证书实现。（保证了信息不会被暴露、不会被篡改、不会将报文传给冒充的服务器）。")])],1),t._v(" "),_("p",[_("strong",[t._v("加密方式")])]),t._v(" "),_("p",[t._v("HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：")]),t._v(" "),_("ul",[_("li",[t._v("在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。")]),t._v(" "),_("li",[t._v("在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据")])]),t._v(" "),_("p",[t._v("采⽤「混合加密」的⽅式的原因：")]),t._v(" "),_("ul",[_("li",[t._v("对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。")]),t._v(" "),_("li",[t._v("⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。")])]),t._v(" "),_("p",[_("strong",[t._v("信息校验")])]),t._v(" "),_("p",[t._v("信息校验是通过摘要算法实现数据的完整性。客户端为明文通过摘要算法生成独一无二的指纹，连同明文一起发送，服务端通过相同算法根据指纹解码校验数据的完整性。")]),t._v(" "),_("p",[_("strong",[t._v("身份认证")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。为了保证公钥的安全，需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证 机构颁发）中，只要证书是可信的，公钥就是可信的")])],1),t._v(" "),_("p",[_("strong",[t._v("身份验证原理")])]),t._v(" "),_("ol",[_("li",[t._v("服务端先将公钥注册到CA机构，CA将此公钥的数字签名发给服务器（通过此数字证书解析公钥）")]),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("客户端在建立起TCP连接后，还需要建立起SSL连接，先向服务器请求数字证书，再通过之前服务器注册到CA的公钥确认证书的真实性来对服务器进行身份认证。（公钥是事先放到客户端本地的）")])],1),t._v(" "),_("li",[t._v("验证数字证书的真实姓后后，客户端取出证书的服务器对公钥进行报文加密传输")])]),t._v(" "),_("p",[_("strong",[t._v("详细流程")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("客户端向服务端发起加密请求")]),t._v(" "),_("ol",[_("li",[t._v("客户端支持的协议版本")]),t._v(" "),_("li",[t._v("客户端生成的随机数，用于生产会话密钥")]),t._v(" "),_("li",[t._v("客户端支持的摘要算法")])])]),t._v(" "),_("li",[_("p",[t._v("服务器响应客户端")]),t._v(" "),_("ol",[_("li",[t._v("确认加密协议版本，如果浏览器不⽀持，则关闭加密通信。")]),t._v(" "),_("li",[t._v("服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。")]),t._v(" "),_("li",[t._v("确认的密码套件列表，如 RSA 加密算法。")]),t._v(" "),_("li",[t._v("服务器的数字证书")])])]),t._v(" "),_("li",[_("p",[t._v("客户端回应")]),t._v(" "),_("p",[t._v("客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：")]),t._v(" "),_("ol",[_("li",[t._v("⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。")]),t._v(" "),_("li",[t._v("加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。")])])]),t._v(" "),_("li",[_("p",[t._v("服务端最后回应")]),t._v(" "),_("p",[t._v("服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘 钥」。然后，向客户端发⽣最后的信息")]),t._v(" "),_("ol",[_("li",[t._v("加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。")]),t._v(" "),_("li",[t._v("服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘 要，⽤来供客户端校验")])])])]),t._v(" "),_("h3",{attrs:{id:"http协议的演变"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议的演变"}},[t._v("#")]),t._v(" HTTP协议的演变")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[_("strong",[t._v("HTTP1.1相比HTTP1.0")])])],1),t._v(" "),_("p",[t._v("改进")]),t._v(" "),_("ul",[_("li",[t._v("实现了TCP长连接减少短链接造成的性能开销")]),t._v(" "),_("li",[t._v("支持管道传输，客户端可连续发送请求，不必等到服务端回应")])]),t._v(" "),_("p",[t._v("瓶颈")]),t._v(" "),_("ul",[_("li",[t._v("不支持响应头部压缩，只支持压缩响应Body部分")]),t._v(" "),_("li",[t._v("仍存在线头阻塞问题，不是真正的并发响应")]),t._v(" "),_("li",[t._v("互相发送冗余的首部造成浪费")]),t._v(" "),_("li",[t._v("没有对请求响应优先级控制")]),t._v(" "),_("li",[t._v("只能客户端请求，服务端被动回应")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[_("strong",[t._v("HTTP1.1与HTTP2.0")])])],1),t._v(" "),_("p",[t._v("改进")]),t._v(" "),_("ul",[_("li",[_("font",{attrs:{color:"orange"}},[t._v("支持HPACK算法进行响应头部压缩，即客户端和服务端共同维护了一张头信息表，对相同的响应头内容进行复用，减少报文冗余")])],1),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("将纯文本报文更换成二进制数据，头信息和数据体都是二进制的，统称为帧，客户端接收后可直接使用二进制信息，无需转换")])],1),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("HTTP2.0的响应信息不再是按顺序发送，同一个连接的数据包可能属于不同的响应，因此需要对数据包进行标记；一个数据包称为数据流，每个数据流有自己的唯一编号，客户端的为奇数，服务端的为偶数。客户端可以指定数据流的优先级")])],1),t._v(" "),_("li",[t._v("多路复用，HTTP2.0可并发发送请求和响应，不再是串行等待响应。比如服务端发现某个请求特别耗时，就会先将处理好的数据先发给客户端，再执行其他操作，完成再继续处理 mmmmmmmmmmmmmmmmmmmm")]),t._v(" "),_("li",[t._v("支持服务端推送，即客户端发起请求，服务端会m")])]),t._v(" "),_("p",[t._v("缺陷")]),t._v(" "),_("p",[t._v("HTTP2.0还是基于单个TCP连接，一旦发送丢包现象，就会触发TCP重传机制，TCP连接的其他请求必须等待丢包重传才能继续执行。"),_("font",{attrs:{color:"orange"}},[t._v("具体原因是因为TCP的字节流协议，TCP层必须保障字节数据是完整有序的，如果中间的序号丢失，即使高位字节被有序接收，应用层也无法从内核读取这部分数据")])],1),t._v(" "),_("p",[_("strong",[t._v("HTTP3.0")])]),t._v(" "),_("p",[t._v("HTTP2.0的缺点在于TCP机制会导致请求阻塞，因此HTTP3将传输层协议改成更加快速的UDP协议（向上无连接不可靠协议）。为了处理UDP的问题需要一套机制让UDP具备一定的可靠性")]),t._v(" "),_("ul",[_("li",[t._v("QUIC有一套自己的可保证传输可靠性的机制，当发生包丢失时，只阻塞对应的数据流，不会妨碍其他请求。")]),t._v(" "),_("li",[t._v("TSL加密协议由1.2更新为1.3，头部压缩算法升级成QPack。")]),t._v(" "),_("li",[t._v("HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接 把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。")])]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211626045.png",alt:"image-20220221162632957"}}),t._v(" "),_("p",[t._v("QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议。但是QUIC的普及仍十分缓慢。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("UDP包之间是无序的，不存在依赖关系和阻塞问题，无需建立握手挥手，所以速度快")])],1),t._v(" "),_("h3",{attrs:{id:"其他问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他问题"}},[t._v("#")]),t._v(" 其他问题")]),t._v(" "),_("p",[_("strong",[t._v("SSL和TSL")])]),t._v(" "),_("p",[t._v("SSL中文名称叫安全套接层，是上世纪60年代中期网景公司设计的，TSL是由于SSL的广泛使用而被标准化后的名，中文名叫传输层安全协议。本质都是为了保障传输层的安全协议，是同一个协议的不同阶段，因此常常并列在一起。")]),t._v(" "),_("h2",{attrs:{id:"_2-2-如何优化http1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-如何优化http1-1"}},[t._v("#")]),t._v(" 2.2 如何优化HTTP1.1")]),t._v(" "),_("h3",{attrs:{id:"尽量减少http请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量减少http请求"}},[t._v("#")]),t._v(" 尽量减少HTTP请求")]),t._v(" "),_("h3",{attrs:{id:"减少http请求次数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少http请求次数"}},[t._v("#")]),t._v(" 减少HTTP请求次数")]),t._v(" "),_("h3",{attrs:{id:"减小服务器返回数据大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减小服务器返回数据大小"}},[t._v("#")]),t._v(" 减小服务器返回数据大小")]),t._v(" "),_("h2",{attrs:{id:"_2-3http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3http2-0"}},[t._v("#")]),t._v(" 2.3HTTP2.0")]),t._v(" "),_("h3",{attrs:{id:"二进制帧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二进制帧"}},[t._v("#")]),t._v(" 二进制帧")]),t._v(" "),_("p",[t._v("​\t\t"),_("code",[t._v("HTTP2.0")]),t._v("与之前版本相比其采用的传输内容是二进制帧格式。其报文首部是9个子节，前3个子节表示帧长度，第四个字节是控制帧，后四个字节是流标识位，但是最高位不存储，因此最多可表示 "),_("code",[t._v("2^31-1")]),t._v("个不同的流。")]),t._v(" "),_("p",[t._v("​\t\tHTTP2将响应报文分为首部帧（header）和消息负载帧（DATA）")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"),_("font",{attrs:{color:"orange"}},[t._v("HTTP2帧格式")])],1),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203030045536.png",alt:"image-20220303004523455"}}),t._v(" "),_("ul",[_("li",[t._v("HTTP2.0响应报文的帧头为9个字节")]),t._v(" "),_("li",[t._v("前三个字节表示帧长度")]),t._v(" "),_("li",[t._v("第四个字节表示帧类型，共10种不同类型")]),t._v(" "),_("li",[t._v("第五个字节表示标志位，可以携带简单的控制消息")]),t._v(" "),_("li",[t._v("后四个字节表示流标识符，最高位不存储，最多可标识 2^31个不同的流")]),t._v(" "),_("li",[t._v("帧头后的是经过哈夫曼压缩的HTTP头部信息和包体")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("一个TCP连接可以并发多个不同的流，根据报文的流标识位区分。一个流（stream）包含多个不同的消息分别对应不同的请求或响应，一个消息可以包含一个或多个HTTP2传输的最小单位帧frame（也就是HTTP1的头部和包体），以二进制形式存储头部和包体数据。"),_("strong",[t._v("不同流的帧可以乱序但同一个流的帧必须是有序的")]),t._v("，")])],1),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203030105566.png",alt:"image-20220303010515877"}}),t._v(" "),_("p",[t._v("客户端的流ID要求是奇数，服务端的要求是偶数，且都只能递增，超过最大标识范围后通过控制帧关闭TCP连接。")]),t._v(" "),_("p",[t._v("可以通过第五个字节的标志位设置流的优先级")]),t._v(" "),_("h3",{attrs:{id:"报文格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#报文格式"}},[t._v("#")]),t._v(" 报文格式")]),t._v(" "),_("h3",{attrs:{id:"首部加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#首部加密"}},[t._v("#")]),t._v(" 首部加密")]),t._v(" "),_("p",[t._v("​\t\t"),_("code",[t._v("http1.1")]),t._v("只支持通过"),_("code",[t._v("gzip")]),t._v("对报文的body进行压缩，其首部存在大量的重复固定的字段（如cookie，accept）会占据大量的带宽。"),_("code",[t._v("http2.0")]),t._v("通过Hpack算法实现首部加密，"),_("code",[t._v("hpack")]),t._v("算法包括静态字典、动态字典、哈夫曼压缩。静态字典是存在"),_("code",[t._v("http2.0")]),t._v("的框架内，包括61个常用的首部信息，动态字典为通信双方共同维护的首部字段。")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​\t\t静态字典：HTTP2将高频率出现的字符串和字段的ASCII码编码为哈夫曼编码表。共61组。")]),t._v(" "),_("p",[t._v("​\t\t动态字典：通信双方共同建立维护一个动态字典，通过索引值标识重复字符串，对字符串进行哈夫曼压缩。")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203030036782.png",alt:"image-20220303003638629"}}),t._v(" "),_("p",[t._v("​\tHTTP2由于采用二进制帧，无需再通过冒号和结尾的空格作为分隔符，改用表示字符串长度的index和length区分")]),t._v(" "),_("ul",[_("li",[t._v("第一个字节标识静态表索引，如果头部字段属于静态表内容且value值随机，首部的前两位固定位01")]),t._v(" "),_("li",[t._v("第二个字节的最高位表示是否经过哈夫曼编码，后七位表示value长度")])]),t._v(" "),_("p",[t._v("服务器为了避免动态表过于庞大影响性能，会限制一个连接的请求数量。")]),t._v(" "),_("h3",{attrs:{id:"服务端推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送"}},[t._v("#")]),t._v(" 服务端推送")]),t._v(" "),_("p",[t._v("​\t\t"),_("code",[t._v("http")]),t._v("协议之前的版本双方通信是一种应答模式，服务端只能被动响应服务端的请求，"),_("code",[t._v("http2.0")]),t._v("在收到客户端的请求时，可以根据请求内容返回与资源相匹配的其他资源。要求客户端的请求流标识是奇数，服务端的流标识是偶数。")]),t._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),_("p",[t._v("​\t\tHTTP2.0虽然实现了一个TCP的并发传输，但是由于TCP是基于字节流的协议，他必须保证交付给应用层的报文是完整的，一旦报文发送丢失，即使后续报文成功接收，前序报文缺少也会导致应用层无法成功从内核拿到数据，从而造成队头阻塞。TCP的三次握手也会影响延迟。")]),t._v(" "),_("p",[t._v("​\t\tTCP的拥塞控制会有个慢启动的过程，影响TCP连接速度，TCP3次握手和TSL四次握手会有3个往返时延。")]),t._v(" "),_("h1",{attrs:{id:"https-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-2"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("p",[t._v("​\t\t为了解决"),_("code",[t._v("http")]),t._v("协议明文传输的安全性问题，"),_("code",[t._v("https")]),t._v("通过在应用层和传输层之间添加了一层SSL/TLS传输层安全协议。实现了信息加密，数据校验，身份验证。")]),t._v(" "),_("h2",{attrs:{id:"数据加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据加密"}},[t._v("#")]),t._v(" 数据加密")]),t._v(" "),_("p",[t._v("​\t\t"),_("code",[t._v("https")]),t._v("的数据加密采用了对称加密和非对称加密的混合加密。在通信建立前期使用的是非对称加密。在通信建立后使用的是对称加密。非对称加密的安全性更强，速度慢，对称加密安全性弱，速度快。")]),t._v(" "),_("h2",{attrs:{id:"数据校验"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据校验"}},[t._v("#")]),t._v(" 数据校验")]),t._v(" "),_("p",[t._v("​\t\t客户端发送报文时会通过摘要算法生成数据指纹，服务端接收后通过相同的算法进行解密验证数据的完整性。")]),t._v(" "),_("h2",{attrs:{id:"身份验证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#身份验证"}},[t._v("#")]),t._v(" 身份验证")]),t._v(" "),_("p",[t._v("​\t\t服务端发给客户端经过CA签名过的数据证书，客户端使用CA公钥进行解密验证服务端身份。")]),t._v(" "),_("h3",{attrs:{id:"ca证书的颁发过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ca证书的颁发过程"}},[t._v("#")]),t._v(" CA证书的颁发过程")]),t._v(" "),_("p",[t._v("RSA")]),t._v(" "),_("ul",[_("li",[t._v("服务器向CA机构申请公开密钥")]),t._v(" "),_("li",[t._v("CA验证完服务器身份后根据密钥的用途、有效期等信息进行哈希计算得到一个hash值")]),t._v(" "),_("li",[t._v("接着使用CA的自己的私钥对hash值进行加密，也就是对证书进行签名，最后将签名加到文件证书上，形成数字证书")])]),t._v(" "),_("h2",{attrs:{id:"连接建立过程-4-次握手-rsa"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接建立过程-4-次握手-rsa"}},[t._v("#")]),t._v(" 连接建立过程 4 次握手\t-RSA")]),t._v(" "),_("h3",{attrs:{id:"第一次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一次握手"}},[t._v("#")]),t._v(" 第一次握手")]),t._v(" "),_("p",[t._v("​\t\t客户端发送给服务端报文信息为客户端生成的一个随机数，客户端支持的加密套件、客户端支持的TSL协议，")]),t._v(" "),_("h3",{attrs:{id:"第二次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二次握手"}},[t._v("#")]),t._v(" 第二次握手")]),t._v(" "),_("p",[t._v("​\t\t服务端收到客户端的报文后，会向CA机构申请公开公钥，CA收到公钥后，后根据公钥的有效期等信息进行hash计算，通过CA私钥对hash值进行加密，返回给服务端一对公私钥，服务端将生成一个随机数、客户端支持的密码套件中的一种加密算法、和对TSL协议版本进行确认，公钥发送给客户端。")]),t._v(" "),_("h3",{attrs:{id:"第三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手"}},[t._v("#")]),t._v(" 第三次握手")]),t._v(" "),_("p",[t._v("​\t\t客户端将通过本地的CA公开密钥对服务端发送的数字证书进行解密，验证服务端身份，取出数字证书的服务端RSA公钥，并生成一个（pre-master）随机数，此时客户端持有第一次握手的随机数、服务端发送的随机数，和pre-master三个随机数，通过三个随机数生成会话密钥，对报文进行加密。")]),t._v(" "),_("p",[t._v("⽣成完会话密钥后，然后客户端发⼀个「Change Cipher Spec」，告诉服务端开始使⽤加密⽅式发送消息。")]),t._v(" "),_("p",[t._v("然后，客户端再发⼀个「Encrypted Handshake Message（Finishd）」消息，"),_("font",{attrs:{color:"orange"}},[t._v("把之前所有发送的数据做个摘要(验证数据完整性)，再⽤会话密钥（master secret）加密⼀下（数据加密），让服务器做个验证，验证加密通信是否可⽤和之前握⼿信息是否有被中途篡改过。")])],1),t._v(" "),_("p",[t._v("​\t\t"),_("font",{attrs:{color:"orange"}},[t._v("第三次握手双方实现3个密钥的共享并生成会话密钥，客户端通知服务器开始以加密方法通信")])],1),t._v(" "),_("h3",{attrs:{id:"第四次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四次握手"}},[t._v("#")]),t._v(" 第四次握手")]),t._v(" "),_("p",[t._v("​\t\t服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双⽅都 验证加密和解密没问题，那么握⼿正式完成。 最后，就⽤「会话密钥」加解密 HTTP 请求和响应了。")]),t._v(" "),_("h2",{attrs:{id:"密钥交换方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#密钥交换方式"}},[t._v("#")]),t._v(" 密钥交换方式")]),t._v(" "),_("h3",{attrs:{id:"rsa加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rsa加密"}},[t._v("#")]),t._v(" RSA加密")]),t._v(" "),_("p",[t._v("​\t\tRSA加密方式不支持向前保密，服务端的私钥可能会泄露，一旦泄露之前所作的操作将无意义")]),t._v(" "),_("h3",{attrs:{id:"dh加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dh加密"}},[t._v("#")]),t._v(" DH加密")]),t._v(" "),_("p",[t._v("​\t\tDH加密通信双方各自生成一个私钥，通过相同的算法生成公钥，双方交换公钥，根据算法解密获得对方的私钥，进行通信。缺点是计算需要耗费大量时间")]),t._v(" "),_("h3",{attrs:{id:"ecdhe加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ecdhe加密"}},[t._v("#")]),t._v(" ECDHE加密")]),t._v(" "),_("p",[t._v("​\t\tDH加密算法加密时需要进行大量计算，耗费时间，因此DCDH改用规定一个椭圆曲线和基点，各自生成私钥于基点相乘形成公钥，双方交换公钥结合乘法交换律结合律实现共享私钥。")]),t._v(" "),_("p",[t._v("与RSA不同的是第二次握手时，服务端会先选择密码套件（密钥协商算法ECDHE、签名算法RSA、对称加密算法、摘要算法、服务端随机数）；再发送数字证书；与RSA不同的是再发完证书服务端还会发送server key exchange的消息，向客户端公开椭圆曲线和基点。")]),t._v(" "),_("blockquote",[_("p",[t._v("选择了名为 named_curve 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给 客户端；")]),t._v(" "),_("p",[t._v("⽣成随机数作为服务端椭圆曲线的私钥，保留到本地；")]),t._v(" "),_("p",[t._v("根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端")]),t._v(" "),_("p",[t._v("为了保证这个椭圆曲线的公钥不被第三⽅篡改，服务端会⽤ RSA 签名算法给服务端的椭圆曲线公钥做个签名")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("最终的会话密钥，就是⽤「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料⽣成 的")])],1),t._v(" "),_("p",[t._v("使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可 以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个消息的往返时间；")]),t._v(" "),_("h1",{attrs:{id:"tls1-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tls1-3"}},[t._v("#")]),t._v(" TLS1.3")]),t._v(" "),_("p",[t._v("​\t\t在 TLS 1.2 的握⼿中，⼀般是需要 4 次握⼿，先要通过 Client Hello （第 1 次握⼿）和 Server Hello（第 2 次握 ⼿） 消息协商出后续使⽤的加密算法，再互相交换公钥（第 3 和 第 4 次握⼿），然后计算出最终的会话密钥。")]),t._v(" "),_("p",[t._v("​\t\tTLS 1.3 把 Hello 和公钥交换这两个消息合并成了⼀个消息， 于是这样就减少到只需 1 RTT 就能完成 TLS 握⼿。")]),t._v(" "),_("p",[_("strong",[t._v("具体做法")])]),t._v(" "),_("p",[t._v("​\t\t"),_("font",{attrs:{color:"orange"}},[t._v("客户端在 Client Hello 消息⾥带上了⽀持的椭圆曲线，以及这些椭圆曲线对应的公钥。 服务端收到后，选定⼀个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这1 个 RTT，双⽅⼿上 已经有⽣成会话密钥的材料了，于是客户端计算出会话密钥，就可以进⾏应⽤数据的加密传输了。")])],1),t._v(" "),_("p",[t._v("​\t\t对于密钥交换算法，废除了不⽀持前向安全性的 RSA 和 DH 算法，只⽀持 ECDHE 算法。")]),t._v(" "),_("blockquote",[_("p",[t._v("客户端支持的椭圆曲线对应公钥已经在第一次握手就给出了，无需在第三次握手交换")])]),t._v(" "),_("h1",{attrs:{id:"quic"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#quic"}},[t._v("#")]),t._v(" QUIC")]),t._v(" "),_("p",[t._v("QUIC使用了UDP作为传输层协议，减少了三次握手的时间延迟，且QUIC使用了TLS1.3的安全协议，客户端无需等待TLS握手完成就开始发送数据；支持0到1个RTT，从而实现快速建立连接。")]),t._v(" "),_("p",[t._v("QUIC协议沿用了HTTP2.0的二进制帧传输数据，不同的stream之间相互隔离，不会导致队头阻塞的问题。")]),t._v(" "),_("p",[t._v("同时，QUIC也采用一些方法来保证传输的可靠性。QUIC的可靠性是使用了包序号（package Number），这这序号是递增的，不同于syn，不管服务器是否收到数据，发送方每次发送的序号都会加1。")]),t._v(" "),_("p",[_("strong",[t._v("QUIC判断超时重传时间")])]),t._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203222352014.webp",alt:"image-20220318092115994"}}),t._v(" "),_("p",[t._v("比如有一个 PN = 10 的数据包在发送的过程中由于某些原因迟迟没到服务器，那么客户端会重传一个 PN = 11 的数据包，经过一段时间后客户端收到 PN = 10 的响应后再回送响应报文，此时的 RTT 就是 PN = 10 这个数据包在网络中的生存时间，这样计算相对比较准确。")]),t._v(" "),_("p",[_("strong",[t._v("数据的可靠性保证")])]),t._v(" "),_("p",[t._v("QUIC引入了"),_("code",[t._v("stream offset")]),t._v("流偏移的概念。一个 stream 可以传输多个 stream offset，每个 stream offset 其实就是一个 PN 标识的数据，即使某个 PN 标识的数据丢失，PN + 1 后，它重传的仍旧是 PN 所标识的数据，等到所有 PN 标识的数据发送到服务器，就会进行重组，以此来保证数据可靠性。到达服务器的 stream offset 会按照顺序进行组装，这同时也保证了数据的顺序性。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("服务端根据流偏移进行数据组装")])],1),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08747c54336f431a9a1c73de93f0be7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image-20220318102638665"}}),t._v(" "),_("h1",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),_("h2",{attrs:{id:"基本认识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本认识"}},[t._v("#")]),t._v(" 基本认识")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211642124.png",alt:"image-20220221164223049"}}),t._v(" "),_("p",[t._v("序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。")]),t._v(" "),_("p",[t._v("确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。⽤来解决不丢包的问题。")]),t._v(" "),_("p",[t._v("控制位：")]),t._v(" "),_("ul",[_("li",[t._v("ACK："),_("font",{attrs:{color:"orange"}},[t._v("该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。 ")])],1),t._v(" "),_("li",[t._v("RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。")]),t._v(" "),_("li",[t._v("SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。")]),t._v(" "),_("li",[t._v("FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的 主机之间就可以相互交换 FIN 位为 1 的 TCP 段")]),t._v(" "),_("li",[_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211726538.png",alt:"image-20220221172635486"}})])]),t._v(" "),_("p",[_("strong",[t._v("什么是TCP")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("IP层是不可靠的，它只负责传输数据包，不保证数据包的有序性和完整性，此功能由传输层的TCP协议完成，TCP要保证数据包的完整性和有序性等。因此TCP协议是面向连接的（一对一连接）、可靠的（保证报文能到达）、基于字节流的传输层协议（保证消息的有序性）。")])],1),t._v(" "),_("p",[t._v("连接：⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝ ⼤⼩称为连接。")]),t._v(" "),_("ul",[_("li",[t._v("Socket：由 IP 地址和端⼝号组成")]),t._v(" "),_("li",[t._v("序列号：⽤来解决乱序问题等")]),t._v(" "),_("li",[t._v("窗⼝⼤⼩：⽤来做流量控制")])]),t._v(" "),_("p",[t._v("源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。")]),t._v(" "),_("p",[t._v("源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。")]),t._v(" "),_("p",[t._v("理论上TCP连接的最大数为客户端IP数乘以客户端端口数。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("一个四元组确定一个TCP连接：源端端口地址、源IP地址、目的端口地址、目的IP地址")])],1),t._v(" "),_("h2",{attrs:{id:"tcp和udp的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[t._v("#")]),t._v(" TCP和UDP的区别")]),t._v(" "),_("ol",[_("li",[t._v("连接\n"),_("ul",[_("li",[t._v("TCP是面向连接的传输层协议，传输前需要建立连接")]),t._v(" "),_("li",[t._v("UDP无需建立连接直接传输数据")])])]),t._v(" "),_("li",[t._v("服务对象\n"),_("ul",[_("li",[t._v("UDP无需建立连接可一对多传输")]),t._v(" "),_("li",[t._v("TCP只能一对一传输")])])]),t._v(" "),_("li",[t._v("可靠性\n"),_("ul",[_("li",[t._v("TCP保证传输数据的完整、有效")]),t._v(" "),_("li",[t._v("UDP只管最大程度地传输，不保证数据的可靠性")])])]),t._v(" "),_("li",[t._v("拥塞控制、流量控制\n"),_("ul",[_("li",[t._v("TCP能够实现拥塞和流量控制，保证数据的安全性")]),t._v(" "),_("li",[t._v("UDP不会受网络因素影响传输速度")])])]),t._v(" "),_("li",[t._v("传输方式\n"),_("ul",[_("li",[t._v("TCP是流式传输，没有边界，保证顺序和可靠")]),t._v(" "),_("li",[t._v("UDP是包传输，具有边界，但可能会乱序和丢包")])])]),t._v(" "),_("li",[t._v("分片\n"),_("ul",[_("li",[t._v("TCP需要在传输层就分片（大于MSS时），为了防止因为网络导致TCP分片丢失而导致整个TCP数据都要重传")]),t._v(" "),_("li",[t._v("UDP如果大于MTU（最大传输单元）就要在IP层分片。因为如果没有分片一个包丢失就会导致所有数据包都要重传。")])])])]),t._v(" "),_("p",[_("strong",[t._v("UDP")])]),t._v(" "),_("p",[t._v("UDP支持一对多、无需连接即时传输、不可靠交付、没有拥塞控制流量控制、首部长度固定开销小。")]),t._v(" "),_("p",[t._v("UDP长运用于视频、音频等媒体通信。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("TCP数据长度  = IP总长度 - IP首部长度（通常20字节） - TCP首都长度（没有选项也是20字节）")])],1),t._v(" "),_("h2",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),_("p",[_("font",{attrs:{color:"pink"}},[_("strong",[t._v("TCP连接建立")])])],1),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211708568.png",alt:"image-20220221170833488"}}),t._v(" "),_("ul",[_("li",[t._v("一开始，客户端和服务端都处于关闭状态。先是服务端主动监听某个端口，处理LISTEN状态")]),t._v(" "),_("li",[t._v("第一次握手客户端会先"),_("font",{attrs:{color:"orange"}},[t._v("随机初始序列号")]),t._v("（"),_("code",[t._v("client_isn")]),t._v("），将此序号置于TCP首部的序号中（32位）中，同时把"),_("code",[t._v("SYN")]),t._v("标志置为1，表示SYN报文。接着把第一个SYN报文发送给服务端。表示向服务端发起连接，该报文包含应用层数据，接着客户端处于"),_("code",[t._v("SYN-SEND")]),t._v("状态\n"),_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211815084.png",alt:"image-20220221181542015"}})],1),t._v(" "),_("li",[t._v("第二次握手服务端收到客户端的"),_("code",[t._v("SYN")]),t._v("报文后，首先"),_("font",{attrs:{color:"orange"}},[t._v("服务端也随机初始化自己的序号（server_isn），将此序号填入TCP首部序号字段中")]),t._v("，其次把对第一次握手报文的序列号+1并写入自己报文的确认应答号（32位），接着把SYN和ACK的标志置为1。最后把报文发给客户端，之和服务端处于 SYN-RCVD状态。\n"),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202211820211.png",alt:"image-20220221182043136"}})],1),t._v(" "),_("li",[t._v("第三次握手客户端收到服务端的报文后，还要向服务端发送最后一个应答报文，首先将报文的ACK标志置为1，将确认应答号 = 服务端报文序号+1，再将报文给服务端，此时报文是可以携带想要传递的数据的。")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("接收双方的新写入确认应答号分别是对方报文的序列号+1")])],1),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[_("strong",[t._v("为什么是三次握手")])])],1),t._v(" "),_("ul",[_("li",[_("font",{attrs:{color:"orange"}},[t._v("三次握手可以避免历史连接的初始化")]),t._v("，网络环境是复杂的，无法保证报文都会按顺序到达。如客户端连续发送多次SYN建立连接的报文，当网络拥堵时，可能导致旧的SYN报文比新的SYN报文先到达服务器，服务器会返回一个SYN+ACK报文给客户端，客户端接收后，可以根据自身上下文判断服务器返回的是一个已经过期的序列号，于是返回一个RST报文，希望终止此次连接。")],1),t._v(" "),_("li",[t._v("如果是两次握手，客户端无法判断当前连接的有效性，但是三次握手可以在返回确认报文前来判断报文，\n"),_("ul",[_("li",[t._v("如果是历史连接，则返回RST报文终止历史连接")]),t._v(" "),_("li",[t._v("如果不是历史连接，返回ACK确认报文，最终确认通信双方成功建立通信")])])]),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("同步双方的初始序列号")]),t._v("，TCP连接要保证应用层能顺利接收报文，需确保报文的有序性，通过报文的序列号，接受方可以对报文进行去重、实现报文按序接收，还可以让发送方确认哪些报文是接受发方已经成功接收。实现双方序号同步。"),_("font",{attrs:{color:"orange"}},[t._v("如果只是两次握手只能确认其中一方成功接收，不能确认序号的同步性。")])],1),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("避免资源浪费")]),t._v("，当客户端的SYN请求在网络中被阻塞，客户端没能收到ACK报文，又会重新发送请求，但是没有第三次握手，服务器并不能确认客户端是否成功接收，于是只能响应客户端新的SYN请求，如果客户端SYN阻塞了，服务器会不断地建立无效冗余连接，造成资源浪费。")],1)]),t._v(" "),_("p",[_("strong",[t._v("为什么客户端和服务端的初始序号ISN不同")])]),t._v(" "),_("p",[t._v("如果一个已经失效的连接被重用了，当历史报文还是存留在网络中的，如果序号相同，就会无法区分报文的有效性，导致数据错乱。另一方面是为了防止黑客伪造相同序号报文。")]),t._v(" "),_("p",[_("strong",[t._v("IP层会分片，为什么TCP还要设置数据最大长度？")]),t._v(" (MSS)")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202212117947.png",alt:"image-20220221211739881"}}),t._v(" "),_("ul",[_("li",[t._v("MTU：最大传输单元，一般为1500字节")]),t._v(" "),_("li",[t._v("MSS：除去IP和TCP头部，一个网络包所能容纳的TCP数据最大长度")])]),t._v(" "),_("p",[t._v("当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成 若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏重新组装后， 再交给上⼀层 TCP 传输层。")]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("IP层不具备超时重传机制，如果一个IP片丢失，整个IP报文的分配都得重传，超时重传将由传输层负责。当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时 后，就会重发「整个 TCP 报⽂（头部 + 数据）」。这会造成报文传输效率低下。为了实现最大传输效能，当TCP发现数据超过MSS时，就会先切片，让IP层无需切片。")])],1),t._v(" "),_("p",[_("strong",[t._v("什么是SYN攻击，如何避免")])]),t._v(" "),_("p",[t._v("攻击者伪造SYN报文，让服务端不断进入第二次握手阶段导致服务端无法正常响应工作。当占满服务端的接收队列，服务器就无法正常工作。")]),t._v(" "),_("p",[t._v("解决方法")]),t._v(" "),_("ol",[_("li",[t._v("修改Linux内核参数，控制SYN队列满时应该直接返回RST，限制SYN-RCVD状态数")])]),t._v(" "),_("h2",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("p",[t._v("TCP 断开连接是通过四次挥⼿⽅式。")]),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202202212129561.png",alt:"image-20220221212959472"}}),t._v(" "),_("ul",[_("li",[t._v("客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客 户端进⼊ FIN_WAIT_1 状态。")]),t._v(" "),_("li",[t._v("服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。")]),t._v(" "),_("li",[t._v("客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。")]),t._v(" "),_("li",[t._v("等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。")]),t._v(" "),_("li",[_("font",{attrs:{color:"orange"}},[t._v("客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态 ")])],1),t._v(" "),_("li",[t._v("服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。")]),t._v(" "),_("li",[t._v("客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。")])]),t._v(" "),_("h2",{attrs:{id:"问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),_("p",[_("strong",[t._v("为什么需要四次挥手")])]),t._v(" "),_("ul",[_("li",[t._v("关闭连接时，客户端会先向服务端发送一个FIN包，但这仅仅表示客户端不会再向服务端发送请求但还是能够接收数据")]),t._v(" "),_("li",[t._v("服务端收到客户端的FIN包时，先回一个ACK应答报文，而服务端可能还有数据需要处理发送，服务端不再需要发送数据时，才会发送FIN包向客户端表示同意关闭连接")])]),t._v(" "),_("p",[_("strong",[t._v("为什么客户端接收到服务端的FIN报文等待2MSL")])]),t._v(" "),_("p",[t._v("MSL表示报文的最大生存时间，超过这个时间此报文会被废弃；而IP头的还有一个TTL字段，表示IP数据包可经过的最大路由数，当经过的路由超过TTL，数据包将被废弃，同时通过ICMP报文告知源主机。")]),t._v(" "),_("p",[_("strong",[t._v("等待2MSL的原因")])]),t._v(" "),_("p",[_("font",{attrs:{color:"orange"}},[t._v("网络中可能还存在一些来自发送方的数据包，这些数据经处理后又会返回去，一来一回需要等待两倍时间。")])],1),t._v(" "),_("p",[_("strong",[t._v("什么是TCP粘包")])]),t._v(" "),_("p",[t._v("TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。")]),t._v(" "),_("p",[t._v("发送方原因")]),t._v(" "),_("ul",[_("li",[t._v("TCP为了减少报文段数量默认使用Nagle算法，此算法会在上一个分组得到确认才会发送下一个分组，收集到多个分组才一起发送发送")])]),t._v(" "),_("p",[t._v("接受发原因")]),t._v(" "),_("p",[t._v("​\t\tTCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。0")]),t._v(" "),_("h1",{attrs:{id:"tcp可靠性实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp可靠性实现"}},[t._v("#")]),t._v(" TCP可靠性实现")]),t._v(" "),_("h2",{attrs:{id:"超时重传"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#超时重传"}},[t._v("#")]),t._v(" 超时重传")]),t._v(" "),_("p",[t._v("​\t\t当数据包在传输过程中发送丢失或者ACK确认报文丢失就会触发。具体是通过发送时设置定时器实现。时间应该略大于一个往返时延（RTT）")]),t._v(" "),_("h2",{attrs:{id:"快速重传"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#快速重传"}},[t._v("#")]),t._v(" 快速重传")]),t._v(" "),_("p",[t._v("​\t\t何时触发超时重传不根据时间决定，而是根据是否收到同样的确认报文决定。比如服务端成功收到了seq1并返回一个确认报文，seq2发送过程中丢失，后续的包都已经成功发送了，但是客户端还是收到同一个确认报文，当连续收到三个相同的确认报文说明包丢失了应该重传。")]),t._v(" "),_("h2",{attrs:{id:"滑动窗口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[t._v("#")]),t._v(" 滑动窗口")]),t._v(" "),_("p",[t._v("​\t\t滑动窗口为了解决往返时延较大情况下的通信效率问题。实现了即使未接收到确认报文，发送方也能知道接受方有没有能力接收新报文。")]),t._v(" "),_("p",[t._v("​\t\tTCP头部有一个Window的字段，告诉发送方自己还能接收多少数据。发送方根据window大小发送数据。")]),t._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203031045054.png",alt:"image-20220303104518969"}}),t._v(" "),_("p",[t._v("发送方通过window字段和两个绝对指针一个相对指针划分")]),t._v(" "),_("ul",[_("li",[t._v("第一个绝对指针指向已发送未确认的第一个字节")]),t._v(" "),_("li",[t._v("第二个绝对指针指向未发送但可发送的第一个字节")]),t._v(" "),_("li",[t._v("相对指针等于第一个绝对指针加上发送窗口大小")])]),t._v(" "),_("p",[t._v("接受方分为已接受确认数据、未接收但可接收数据，未接收无能力处理数据")]),t._v(" "),_("ul",[_("li",[t._v("通过接收窗口大小和指向第一个可接收的字节划分")])]),t._v(" "),_("h2",{attrs:{id:"流量控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[t._v("#")]),t._v(" 流量控制")]),t._v(" "),_("p",[t._v("发送发根据接收方的实际能力控制发送的数据量机制。TCP通过让接受方更新窗口大小来进行流量控制。")]),t._v(" "),_("p",[t._v("接受方不能在缩小窗口的同时减小缓冲区大小，否则可能会让发送方造成可用窗口大小为负值，因为接收窗口的大小不能及时反馈到发送方，因先缩小窗口大小通知发送方，再实际减小缓存区大小。")]),t._v(" "),_("p",[t._v("当接收窗口为0时，接收发会阻止发送方的数据传递，当又有接收能力时，会发送窗口非0报文，如果发生丢失，会造成双方死锁等待状态。因此TCP设置了持续定时器发送窗口探测报文更新窗口大小。探测次数超过一定次数都返回零会设置RST控制位关闭连接。")]),t._v(" "),_("p",[t._v("当接受方可接收的数据很小时，发送方也会继续发送，耗费的开销大于数据的传输大小。可以通过Nagle算法当数据大于等于MSS时才发送")]),t._v(" "),_("h2",{attrs:{id:"拥塞控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[t._v("#")]),t._v(" 拥塞控制")]),t._v(" "),_("p",[t._v("网络是共享的，为了避免单个发送方的数据沾满网络，因此发送方还会通过维护一个拥塞窗口控制数据发送。因此实际上发送方能发送的数据大小是发送窗口和拥塞窗口中取小值。")]),t._v(" "),_("p",[t._v("拥塞窗口实际上是通过一个swnd的状态量控制，单位是MSS。")]),t._v(" "),_("p",[t._v("当发送超时重传就认为是网络拥堵。")]),t._v(" "),_("p",[t._v("控制算法")]),t._v(" "),_("ul",[_("li",[t._v("慢启动：一开始cwnd是1，根据收到的ACK呈指数增长，慢启动的门限是")]),t._v(" "),_("li",[t._v("拥塞避免算法：当超过慢启动门限时触发，增长改为线性增长。")]),t._v(" "),_("li",[t._v("拥塞发生：当发生超时重传就认为发生了拥塞，触发拥塞发生算法，分为超时重传和快速重传。超时重传较为激进，直接减半慢启动门限，cwnd置为1；快速重传将cwnd减半，门限为原型cwnd的一半")]),t._v(" "),_("li",[t._v("快速恢复：快速恢复和快速重传一般一起使用，如果能收到3个重复的ACK包说明网络并不算糟糕，当收到3个相同的ACK包后又收到新的ACK会重新进入拥塞避免状态。")])]),t._v(" "),_("h1",{attrs:{id:"tcp粘包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包"}},[t._v("#")]),t._v(" TCP粘包")]),t._v(" "),_("h2",{attrs:{id:"什么是tcp粘包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是tcp粘包"}},[t._v("#")]),t._v(" 什么是TCP粘包")]),t._v(" "),_("p",[t._v("​\t\t"),_("strong",[t._v("TCP粘包")]),t._v("是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。原因是TCP是流式传输的，它将应用层结构化的数据视为无结构的字节流（应用层通过socket交付给传输层），这些字节流在传输层层没有明确的边界，")]),t._v(" "),_("h2",{attrs:{id:"什么情况下发生"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下发生"}},[t._v("#")]),t._v(" 什么情况下发生")]),t._v(" "),_("ol",[_("li",[t._v("TCP连接复用的情况下，多个进程将不同结构体数据送到传输层，没有进行边界分割。")]),t._v(" "),_("li",[t._v("TCP为了提高传输效率，发送方会默认开启nagle算法，算法策略是没有已发送未确认的报文时，立即发送数据；存在未确认的报文时，只有等到待传输的数据大于MSS时才发送。如果nagle在分组拼接没有做好边界划分，接收方解包就会出现粘包。")]),t._v(" "),_("li",[t._v("应用缓冲区的数据大于发送缓冲区的大小，导致一部分数据已经发送被接收，另一部分刚进入发送缓冲区。")]),t._v(" "),_("li",[t._v("接受方没有及时处理接收缓冲区数据，接收方服务器繁忙导致。")])]),t._v(" "),_("h2",{attrs:{id:"解决方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),_("ol",[_("li",[t._v("如果我们传输的数据多是小数据包的交互，可以关闭nagle算法。")]),t._v(" "),_("li",[t._v("发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。")]),t._v(" "),_("li",[t._v("发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。")]),t._v(" "),_("li",[t._v("可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。")])]),t._v(" "),_("h1",{attrs:{id:"udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),_("p",[t._v("UDP 是"),_("strong",[t._v("面向报文")]),t._v("的，所谓面向报文，是指面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。")]),t._v(" "),_("p",[t._v("UDP 是"),_("strong",[t._v("不具有可靠性")]),t._v("的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。")]),t._v(" "),_("p",[t._v("UDP有以下特点：")]),t._v(" "),_("ul",[_("li",[t._v("UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。")]),t._v(" "),_("li",[t._v("传输途中出现丢包，UDP 也不负责重发。")]),t._v(" "),_("li",[t._v("当包的到达顺序出现乱序时，UDP没有纠正的功能。")]),t._v(" "),_("li",[t._v("并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。")]),t._v(" "),_("li",[t._v("如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。")]),t._v(" "),_("li",[t._v("UDP 常用于以下几个方面：\n"),_("ul",[_("li",[t._v("1.包总量较少的通信（DNS、SNMP等）；")]),t._v(" "),_("li",[t._v("2.视频、音频等多媒体通信（即时通信）；")]),t._v(" "),_("li",[t._v("3.限定于 LAN 等特定网络中的应用通信；")]),t._v(" "),_("li",[t._v("4.广播通信（广播、多播）。")])])])]),t._v(" "),_("h1",{attrs:{id:"quic-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#quic-2"}},[t._v("#")]),t._v(" QUIC")]),t._v(" "),_("h2",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),_("p",[t._v("由于 TCP、UDP 协议是系统内核实现的，更新修改起来并不很方便，而 QUIC 是软件层面实现的，更新迭代起来非常方便。")]),t._v(" "),_("p",[t._v("UDP 本身是无序传输的，这在单个连接上并行传输多个数据有天生的优势：多个数据直接发送即可，由 QUIC 对收到的数据进行重新组合排序，然后送往上层应用。这中间不用等待各种数据确认包，效率非常高。")]),t._v(" "),_("p",[t._v("在建立 TCP 连接时，需要进行至少三次握手，如果要开启 TLS 加密，则还需要进行 TLS 握手。而 QUIC 采用了类似于 TCP Fast Open 的技术，如果之前连接过，那么之后可以不用重复握手而直接开始传送数据，以实现 0-RTT 往返时延。即便之前没有连接过，也可以在 1-RTT 内完成连接并开始传送数据。并且自身就拥有与 TLS 等效的加密措施。")]),t._v(" "),_("p",[t._v("在发生丢包时，TCP 会重传丢失的包。而 QUIC，则使用了一种非常神奇的前向纠错算法，通过连续的几个数据包的校验和，可以直接恢复出丢失的包内容，而不需要重传。")]),t._v(" "),_("p",[t._v("在移动端表现更好：用户的网络环境并不稳定，Wi-Fi、4G、3G、2G 之间来回变化，IP 一旦发生变化，TCP 的连接是不可能保持的。而 QUIC 就不存在这样的问题，通过 ID 来标识用户（而不是 IP + 端口），在连接切换后直接恢复之前的连接会话。")]),t._v(" "),_("p",[t._v("配合 HTTP/2 API 食用更佳：由于 HTTP/2 采用二进制帧传输机制，QUIC 直接使用这样的机制进行数据传输，效率更高！")]),t._v(" "),_("h1",{attrs:{id:"ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ip"}},[t._v("#")]),t._v(" IP")]),t._v(" "),_("h2",{attrs:{id:"ip地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ip地址"}},[t._v("#")]),t._v(" IP地址")]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\underwood\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220321135014556.png",alt:"image-20220321135014556"}}),t._v(" "),_("p",[_("strong",[t._v("无分类IP CIRD")])]),t._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203211351674.png",alt:"image-20220321135148595"}}),t._v(" "),_("h2",{attrs:{id:"dns"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[t._v("#")]),t._v(" DNS")]),t._v(" "),_("p",[t._v("工作过程")]),t._v(" "),_("p",[t._v("浏览器首先查看缓存有没有域名对应的IP，没有询问操作系统，还没有检查本机域名解析文件host，还是没有进行DNS服务查询")]),t._v(" "),_("ol",[_("li",[t._v("客户端向本地DNS服务器询问，本地DNS服务器没有请求根域名服务器，根域名服务器发送方顶级域名服务器地址给本地DNS")]),t._v(" "),_("li",[t._v("本地DNS发生请求到顶级域名服务器，顶级域名服务器发送对应区域的权威域名服务器地址给本地DNS")]),t._v(" "),_("li",[t._v("本地DNS发送请求到权威域名服务器，权威域名服务器返回对应的IP")])]),t._v(" "),_("h2",{attrs:{id:"arp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arp"}},[t._v("#")]),t._v(" ARP")]),t._v(" "),_("p",[t._v("主机的路由表会记录下一跳的IP地址，主机会将下一条的IP递增封装在ARP请求包内广播出去，如果收到请求包的主机拆解后发现目的IP地址就是自己的IP地址，会将自己的MAC地址塞入响应包返回。操作系统一般会缓存第一次获取的MAC地址，但存储一般会有期限。")]),t._v(" "),_("p",[t._v("还有一个RAPP协议是已知MAC地址，请求IP地址。通常需要架设一台RAPP服务器，在服务器注册设备的MAC地址和IP地址。")]),t._v(" "),_("h2",{attrs:{id:"dchp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dchp"}},[t._v("#")]),t._v(" DCHP")]),t._v(" "),_("p",[t._v("通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程。")]),t._v(" "),_("ul",[_("li",[t._v("客户端先发起DHCP报文，由于此时客户端还没有IP地址，也不知道DHCP服务器地址，于是使用UDP广播，以255.255.255.255为目的地址（67端口），以0.0.0.0（68端口）为源广播出去。DHCP客户端将IP数据包交给链路层，链路层将帧广播到所有的网络设备。")]),t._v(" "),_("li",[t._v("DHCP服务器收到后，会以255.255.255.255为广播地址，发出携带IP地址、子网掩码、默认网关的报文。")]),t._v(" "),_("li",[t._v("客户端收到后，选择一个DHCP报文，向对应DHCP服务器发起请求拿到配置参数。")])]),t._v(" "),_("p",[t._v("如果IP到期，客户端会向提供IP的DHCP服务器发起请求继续租用，服务器允许返回ACK，不允许返回NACK报文。")]),t._v(" "),_("h2",{attrs:{id:"nat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nat"}},[t._v("#")]),t._v(" NAT")]),t._v(" "),_("p",[t._v("为了解决IP地址紧缺的问题，通过NAT路由器，几个私有IP地址共享一个公有IP地址，并一个端口号作为区分。具体是的转化表是NAT路由生成的。")]),t._v(" "),_("p",[t._v("缺点是外部无法主动与NAT内部进行交流，因为NAT表无法找到请求的IP和私有的IP的映射关系。")]),t._v(" "),_("h2",{attrs:{id:"icmp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#icmp"}},[t._v("#")]),t._v(" "),_("font",{attrs:{color:"orange"}},[t._v("ICMP")])],1),t._v(" "),_("p",[t._v("互联网控制报文协议")]),t._v(" "),_("p",[t._v("ICPM可以确认IP包是否成功送达目标，报告发送过程中IP包被丢弃的原因和改善网络环境等。")]),t._v(" "),_("p",[t._v("ICMP报文大致分为：查询报文类型、差错报文类型。")]),t._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203211401431.png",alt:"image-20220321140155333"}}),t._v(" "),_("h2",{attrs:{id:"子网掩码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#子网掩码"}},[t._v("#")]),t._v(" 子网掩码")]),t._v(" "),_("p",[t._v("当请求的IP地址属于同一个网段时，ARP广播是可以被同一个网段的目的IP接收，ARP广播无法通过网关。因此需要子网掩码判断目的IP和源IP是否是同一个网段，不是的话需要网关介入代理转发。")]),t._v(" "),_("h2",{attrs:{id:"ping"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ping"}},[t._v("#")]),t._v(" Ping")]),t._v(" "),_("p",[t._v("ping是基于ICMP协议工作的。")]),t._v(" "),_("p",[t._v("执行ping命令时，接收端成功收到主机会返回 ICMP类型为8的回送请求，也可以接收回送应答。")]),t._v(" "),_("p",[t._v("如果不可达分为网络、主机、协议、端口不可达，需要切片但设置了不可分片。")]),t._v(" "),_("p",[t._v("对应IP报文，其有个TLL字段叫生存周期，每经过一个路由器此字段值-1，当为0ICMP会丢弃报文并返回超时信息。TLL是为了避免进入路由死循环。此报文为类型11.")]),t._v(" "),_("h1",{attrs:{id:"键入网址到网页解析的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#键入网址到网页解析的过程"}},[t._v("#")]),t._v(" 键入网址到网页解析的过程")]),t._v(" "),_("h2",{attrs:{id:"url解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#url解析"}},[t._v("#")]),t._v(" URL解析")]),t._v(" "),_("p",[t._v("​\t\t首先是对"),_("code",[t._v("url")]),t._v("进行解析，判断是合法的URL还是一个关键词自动完成字符编码等操作。不同浏览器一般采用的编码方式不同，可以使用JavaScript进行编码统一输出，目前主要使用encodeURLComponent和encodeURL进行编码。两者的主要区别是前者对URL的组成部分进行个别编码，后者会对整个URL进行编码")]),t._v(" "),_("h2",{attrs:{id:"dns查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns查询"}},[t._v("#")]),t._v(" DNS查询")]),t._v(" "),_("p",[t._v("浏览器先检查自身缓存，没有找操作系统缓存，再没有找host文件，再没有找路由器缓存，再没有找本地DNS服务器，再没有请求根域名服务器，根域名服务器返回顶级域名服务器，请求顶级域名服务器返回区域权威域名服务器，最后返回真实的IP地址。")]),t._v(" "),_("h2",{attrs:{id:"协议栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协议栈"}},[t._v("#")]),t._v(" 协议栈")]),t._v(" "),_("p",[t._v("获取到目的IP地址后，首先浏览器将会构造"),_("code",[t._v("http")]),t._v("报文，包括请求头（请求方法、目的地址等）和请求体，然后调用socket库委托操作系统的协议栈工作。")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("http")]),t._v("是通过面向连接、可靠、基于字节流的TCP协议传输的，需要通过三次握手建立TCP连接保证双方具备通信能力，第一次握手客户端随机生成序列号，将报文syn置为1发送一个syn包到服务端（处于syn-send阶段），第二次握手服务端收到后也会生成自己的syn包应答客户端请求，包首部的序列号为服务端随机生成，syn和ack控制位为1，确认应答号为客户端序列号+1（处于syn-rcvd阶段）。客户端收到服务端的应答后将进行第三次握手，首先是报文的ack置为1，确认应答号为服务端序列号+1，此时双方已具备通信能力。")]),t._v(" "),_("li",[t._v("TCP报文如果超过MSS后会进行切片，在每个TCP分片加上TCP首部信息。TCP报文会有两个端口浏览器监听端口通常为随机生成、http服务端口默认是80，https是443.")]),t._v(" "),_("li",[t._v("接着将TCP切片交由IP模块封装成网络包发送给通信对象。IP协议要有源IP地址和目的IP地址，如果发送方存在多个网卡源目的地址通过路由表决定。")]),t._v(" "),_("li",[t._v("网络包添加好IP报文头后需要加上MAC头部(包括源MAC地址、目的MAC地址各6字节、协议类型2字节共14各字节)，用于两点传输，源MAC地址通过只读存储器获取，目的MAC地址根据IP地址通过ARP协议（广播）获取路由器MAC地址")]),t._v(" "),_("li",[t._v("最终形成的数据包只是内存的二进制信息，需要通过网卡转成电信号在网线传输。")])]),t._v(" "),_("h2",{attrs:{id:"服务端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端"}},[t._v("#")]),t._v(" 服务端")]),t._v(" "),_("p",[t._v("服务器会主动监听http请求，收到后解析MAC和IP地址是否匹配、查看TCP头部序列号是否完整有序，如果包符合会放入缓存返回一个ACK，否则丢弃。http服务会监听TCP头部端口号，根据客户端请求将网页封装在http响应报文体内。最终发送给浏览器")]),t._v(" "),_("h2",{attrs:{id:"浏览器接收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器接收"}},[t._v("#")]),t._v(" 浏览器接收")]),t._v(" "),_("p",[t._v("浏览器接收到响应资源后，会对资源进行分析，根据状态码进行不同操作，如302临时重定向等，304协商缓存等。如http1.1的body解压缩。同时浏览器会缓存响应资源。")]),t._v(" "),_("p",[t._v("浏览器在处理完资源后开始通过浏览器内核根据响应内容渲染页面。")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("HTML解析")]),t._v(" "),_("ul",[_("li",[t._v("解码先将二进制数据转为指定编码字符串")]),t._v(" "),_("li",[t._v("预解析：提前加载资源，减少处理时间，如img标签的图片资源")]),t._v(" "),_("li",[t._v("符号化：通过状态机对HTML符号（如标签属性）进行词法分析")]),t._v(" "),_("li",[t._v("构建树：符号化和构建树并行操作，是一个边分析分创建DOM节点树的过程")]),t._v(" "),_("li",[t._v("浏览器的容错机制会纠正词法错误，通过DOMConentenLoad通知DOM解析接收")])])]),t._v(" "),_("li",[_("p",[t._v("css解析")]),t._v(" "),_("p",[t._v("css解析器会处理遇到的css，根据语法规范解析标记得到css规则树，节点匹配css时是从左往右的顺序")])]),t._v(" "),_("li",[_("p",[t._v("渲染树")]),t._v(" "),_("p",[t._v("渲染树是根据DOM树和css规则树计算级联生成，浏览器会根据样式的权重来对元素进行渲染，当遇到script标签时会阻塞DOM的构建，可以设置async或defer属性异步加载")])]),t._v(" "),_("li",[_("p",[t._v("布局绘制")]),t._v(" "),_("p",[t._v("浏览器排版引擎确定渲染树各个节点的几何属性，精确捕获每个元素在屏幕的大小和位置。遍历渲染树，调用渲染器的paint方法在屏幕显示")])]),t._v(" "),_("li",[_("p",[t._v("合并渲染")]),t._v(" "),_("p",[t._v("把以上绘制的图片合并，输出成一张图片。")])])]),t._v(" "),_("h1",{attrs:{id:"cdn"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[t._v("#")]),t._v(" CDN")]),t._v(" "),_("p",[t._v("​\t\t内容分布式网络，将源站的内容分发到用户最近的网络边缘，使得用户能够就近获取数据，不仅降低了网络拥塞状态，提高了响应速度，还可以减轻源站的负载压力")]),t._v(" "),_("ul",[_("li",[t._v("本地DNS系统解析，查找缓存")]),t._v(" "),_("li",[t._v("本地没有返回CDN的DNS服务器地址")]),t._v(" "),_("li",[t._v("CDN的DNS服务器返回全局负载均衡的设备IP给用户")]),t._v(" "),_("li",[t._v("用户向全局负载均衡发起URL请求")]),t._v(" "),_("li",[t._v("CDN负载均衡根据用户IP及请求的URL内容返回用户所属区域负载均衡设备，将请求转发到此设备，区域负载均衡根据用户IP选择最优的缓存服务器的IP给全局负载均衡设备，全局负载均衡再将IP给用户。")])]),t._v(" "),_("h1",{attrs:{id:"网络攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络攻击"}},[t._v("#")]),t._v(" 网络攻击")]),t._v(" "),_("h2",{attrs:{id:"dns-劫持"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns-劫持"}},[t._v("#")]),t._v(" DNS 劫持")]),t._v(" "),_("p",[t._v("DNS劫持成为DNS重定向，通过覆盖计算机的TCP/IP设置，将个人查询重定向到域名服务器DNS。这可以通过使用恶意软件或修改服务器的设置来实现。一旦执行DNS劫持，他们就可以使用它来将流量引导到不同的网站。")]),t._v(" "),_("p",[t._v("要执行攻击，犯罪者要么在用户计算机上安装恶意软件，要么接管路由器，要么拦截或破解DNS通信。DNS劫持可用于域欺骗或用于网络钓鱼。")]),t._v(" "),_("p",[_("strong",[t._v("DNS劫持的四种基本类型")]),t._v(":")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("本地DNS劫持")]),t._v(":攻击者在用户计算机上安装木马恶意软件，并更改本地DNS设置以将用户重定向到恶意站点。")]),t._v(" "),_("li",[_("strong",[t._v("路由器DNS劫持")]),t._v(":许多路由器都有默认密码或固件漏洞，攻击者可以接管路由器并覆盖DNS设置，从而影响连接到该路由器的所有用户。")]),t._v(" "),_("li",[_("strong",[t._v("中间DNS攻击")]),t._v("：攻击者拦截用户和DNS服务器之间的通信，并提供指向恶意站点的不同目标ip地址。")]),t._v(" "),_("li",[_("strong",[t._v("流氓DNS服务器")]),t._v(":攻击者攻击DNS服务器，并更改DNS记录以将DNS请求重定向到恶意站点。")])]),t._v(" "),_("h1",{attrs:{id:"状态码-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态码-2"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),_("h2",{attrs:{id:"_1xx-消息性状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1xx-消息性状态码"}},[t._v("#")]),t._v(" 1xx（消息性状态码）")]),t._v(" "),_("p",[t._v("如"),_("code",[t._v("websocket")]),t._v("申请升级协议返回101表示服务器正在进行协议切换")]),t._v(" "),_("h2",{attrs:{id:"_2xx-成功状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-成功状态码"}},[t._v("#")]),t._v(" 2xx （成功状态码）")]),t._v(" "),_("ul",[_("li",[t._v("200：表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。")]),t._v(" "),_("li",[t._v("201：表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。")]),t._v(" "),_("li",[t._v("202：表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。")]),t._v(" "),_("li",[t._v("204：表示目前请求成功，但客户端不需要更新其现有页面。")])]),t._v(" "),_("h2",{attrs:{id:"_3xx-重定向状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-重定向状态码"}},[t._v("#")]),t._v(" 3xx （重定向状态码）")]),t._v(" "),_("ul",[_("li",[t._v("301：永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。")]),t._v(" "),_("li",[t._v("302：临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个URL，但是搜索引擎不会对该资源的链接进行更新。")]),t._v(" "),_("li",[t._v("303：通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。")]),t._v(" "),_("li",[t._v("304：说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD, 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。")]),t._v(" "),_("li",[t._v("307：临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。")]),t._v(" "),_("li",[t._v("308：永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。")])]),t._v(" "),_("h2",{attrs:{id:"_4xx-客户端错误状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-客户端错误状态码"}},[t._v("#")]),t._v(" 4xx（客户端错误状态码）")]),t._v(" "),_("ul",[_("li",[t._v("400：表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。如报文错误")]),t._v(" "),_("li",[t._v("401：说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。")]),t._v(" "),_("li",[t._v("403：指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）")]),t._v(" "),_("li",[t._v("404：说明服务器没有找到所请求的资源，且响应的链接为死链；404 不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410 (Gone) 而不是 404 。")]),t._v(" "),_("li",[t._v("405：表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。")]),t._v(" "),_("li",[t._v("406：表示服务器端不支持 Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的。")]),t._v(" "),_("li",[t._v("413：请求主体大于服务器限度，可能会导致服务器关闭连接。")]),t._v(" "),_("li",[t._v("414：请求url长度大于服务器允许范围。")])]),t._v(" "),_("h2",{attrs:{id:"_5xx-服务端错误状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-服务端错误状态码"}},[t._v("#")]),t._v(" 5xx（服务端错误状态码）")]),t._v(" "),_("ul",[_("li",[t._v("500：服务器内部错误，一个较笼统的错误消息。")]),t._v(" "),_("li",[t._v("502：表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。")]),t._v(" "),_("li",[t._v("503：表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);