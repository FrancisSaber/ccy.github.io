(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{658:function(t,a,e){"use strict";e.r(a);var r=e(10),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"html解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html解析"}},[t._v("#")]),t._v(" HTML解析")]),t._v(" "),e("ul",[e("li",[t._v("浏览器下载好HTML文档后，会对HTML文档进行编码格式转化")]),t._v(" "),e("li",[t._v("接着对HTML文档进行解析成有意义的tokens段，构建DOM结点树，同时浏览器会并行下载解析CSS资源构建CSS规则树，CSS规则树的构建不会阻塞DOM结点树的构建，但会阻塞DOM结点的渲染。")])]),t._v(" "),e("h1",{attrs:{id:"合成渲染树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成渲染树"}},[t._v("#")]),t._v(" 合成渲染树")]),t._v(" "),e("ul",[e("li",[t._v("当DOM树和CSS规则树构建好后，GUI线程会从DOM结点的根对象出发，查询样式表构建Render Tree（渲染树）；样式表的查询是从右向左查找匹配的，因此不应该重叠过多的选择器。")]),t._v(" "),e("li",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203101437906.webp",alt:"GitHub"}})])]),t._v(" "),e("h1",{attrs:{id:"布局排版"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#布局排版"}},[t._v("#")]),t._v(" 布局排版")]),t._v(" "),e("ul",[e("li",[t._v("当渲染树构建好后，浏览器根据DOM结点的盒子模型类型，在页面上")]),t._v(" "),e("li",[t._v("当你对一个文档进行布局(laying out)时候, 浏览器引擎会根据渲染树元素结点的几何属性和CSS样式，将元素描述成一个盒子模型，确认结点在页面的具体位置和大小")])]),t._v(" "),e("h1",{attrs:{id:"绘制、渲染层合并、显示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制、渲染层合并、显示"}},[t._v("#")]),t._v(" 绘制、渲染层合并、显示")]),t._v(" "),e("p",[t._v("当排版布局好后，调用渲染器的print方法绘制页面的像素信息。")]),t._v(" "),e("p",[t._v("一个DOM结点对应一个渲染对象，渲染对象保持了树的结构，渲染对象通过绘图上下文（GraphicsContext）发出绘制调用来绘制DOM结点。")]),t._v(" "),e("p",[t._v("在DOM树中的每个结点都会对应一个渲染对象，当不同的渲染对象位于相同的z轴立体空间时，就会形成一个渲染层，对于页面中DOM元素的绘制就是在多个渲染层（对应不同坐标元素）进行的。对于满足形成层叠上下文的渲染对象，浏览器会单独创建一个新的渲染层（如有明确的定位属性的元素），但这个渲染对象仍需要与它的子元素共享渲染层。")]),t._v(" "),e("p",[t._v("在每个层上完成绘制过程之后,浏览器会将绘制的位图发送给 GPU 绘制到屏幕上,将所有层按照合理的顺序合并成一个图层,然后在屏幕上呈现。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203101520039.webp",alt:"composite"}})]),t._v(" "),e("p",[t._v("浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面")]),t._v(" "),e("h1",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),e("h2",{attrs:{id:"回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),e("p",[t._v("回流是当页面某个结点的几何属性改变后，需要重新计算结点的位置和大小，重写对对节点进行排版布局的，通常某个结点的改变影响的不仅仅是结点本身，其他与其有关的也会被影响，浏览器为了避免频繁的回流，通常会缓存一个队列，待达到一定数量时一次性回流；但某些情况会导致队列立即被清空执行，如获取clientHeight等需要获得精确值的时候。")]),t._v(" "),e("h2",{attrs:{id:"重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),e("h2",{attrs:{id:"domcontentloaded和onload"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded和onload"}},[t._v("#")]),t._v(" DOMContentLoaded和onLoad")]),t._v(" "),e("p",[t._v("当DOM结点树构建完成后会触发DOMContentLoaded，CSS规则树构建不会影响DOM树的构建；DOMContentLoaded触发不需要等待图片等其他资源加载完成，但如果文档解析js脚本则会延迟。")]),t._v(" "),e("p",[t._v("当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。")]),t._v(" "),e("p",[e("strong",[t._v("当解析时没有遇到JavaScript")])]),t._v(" "),e("img",{staticStyle:{zoom:"40%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203101239029.png",alt:"image-20220310123936876"}}),t._v(" "),e("p",[e("strong",[t._v("当在解析HTML节点时遇到JavaScript代码")])]),t._v(" "),e("img",{staticStyle:{zoom:"40%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203101239089.png",alt:"image-20220310123904932"}}),t._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/FrancisSaber/image/markdown-Image202203101236847.webp",alt:"workflow"}})])}),[],!1,null,null,null);a.default=s.exports}}]);